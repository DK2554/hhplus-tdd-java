# 동시성 제어 보고서

동시성 제어? 한 자원을 여러곳에서 동시에 공유를 해서 발생하는건가? 까지가 내가 알고 있는 지식이다.

동시성 제어란? 여러 스레드나 트랜잭션이 동시에 데이터를 변경하려 하면, 최종 결과가 충돌하거나 잘못된 데이터가 저장이 될수 있는것처럼 데이터의 불일치나 손실을 야기한다.

매번 동시성, 동시성 이란 단어만 들어왔지 이거를 어떻게 해결할까? 하는 고민은 해보지 못했다.

그래서 이번 기회에 동시성을 제어할 수 있는 방법들 찾아봤었다.

동시성을 제어할 수 있는 방법

1. **Synchronized** : 내가 알고 있는 기본적인 동기화 방식이였다.
2. **Reentrantlock** : 항해를 시작하면서 처음 들어본 동시성 제어 방법이다.
3. **ConcurrentHashMap**: : 해당 Map도 들어보기만하고 직접 경험해보지는 못했다.

우선 이 두가지를 찾아보았다. 보편적으로 많이 알고 있는 **Synchronized**은 청강에서도 많은 멘토들이 말씀하시길 제일 좋지 않은 방법이라고 말씀하셨다.

우선

> **Synchronized**
> 
- Java에서 스레드 간 동기화를 보장하기 위해 사용한다.
- 특정 코드 블록이나 메서드에 **Synchronized** 선언해서 사용하면 한번에 하나의 스레드만 접근 할 수 있도록 한다.
- 기본적인 동작 방법이다.

```jsx
public synchronized void 증가() {
    counter++;
}
```

---

?? 그러면 왜 쓰면 안되는거야? 라고 생각해서 청강도 듣고 찾아도 보았다.

**성능 문제**

- **블로킹 이슈**: `synchronized` 블록이나 메서드에 접근하기 위해 스레드가 순서를 기다려야 하므로 병렬 처리가 제한됩니다.
- 락을 기다리는 스레드는 **컨텍스트 스위칭**과 **스케줄링 오버헤드**를 유발하여 성능에 부정적인 영향을 미칩니다.

<aside>
💡

> 결국에 내가 접근하려면 순서를 기다려서 해서 다른 작업을 할 수없다는 거구나
> 
</aside>

- **과도한 락 사용**
    - 불필요하게 큰 범위를 `synchronized`로 동기화하면 성능이 크게 저하될 수 있습니다.
    - 예: 특정 연산만 동기화하면 될 때, 전체 메서드를 동기화할 경우 병목 현상이 발생.
- **공정성(Fairness) 문제**
    - `synchronized`는 락을 획득할 스레드를 선택하는 기준이 명확하지 않아, 특정 스레드가 오래 기다리게 될 수 있습니다.

<aside>
💡

특정 연산만 동기화하면 되는걸 전체에 걸어서 병목이 발생하고, 내가 원하는 순차적으로 할 수 없어서 `synchronized`로 동시성을 제어하면 안좋다.

</aside>

> **Reentrantlock ? 처음들어봐요**
> 

`ReentrantLock`은 Java의 `java.util.concurrent.locks` 패키지에 있는 동기화 클래스입니다. 기본적으로 `synchronized` 키워드의 대체로 사용되며, **재진입 가능한(explicitly reentrant)** 락을 제공합니다. 이 락은 동일한 스레드가 여러 번 락을 획득할 수 있게 하며, 명시적으로 락의 제어와 동작을 설정할 수 있도록 설계되었습니다. (GPT)

## 기본동작 방법

```jsx
  private final ReentrantLock lock = new ReentrantLock();

  public void criticalSection() {
      lock.lock(); // 락 획득
      try {
          // 중요 작업 수행
          System.out.println("Executing critical section by " + Thread.currentThread().getName());
      } finally {
          lock.unlock(); // 락 해제
      }
  }
```

### ReentrantLock의 주요 특징과 이점

1. **재진입 가능**:
    - 동일한 스레드가 이미 획득한 락을 다시 획득할 수 있습니다. 이는 재귀적으로 호출되는 메서드에서 유용합니다.
2. **명시적 락 제어**:
    - `lock()`과 `unlock()`을 사용해 명시적으로 락을 제어할 수 있습니다.
    - `Condition` 객체를 사용해 세밀한 대기/알림 메커니즘을 구현할 수 있습니다.
3. **공정성 설정**:
    - `new ReentrantLock(true)`로 공정성을 설정해 락의 획득 순서를 보장할 수 있습니다.
4. **tryLock**:
    - 락을 기다리지 않고, 즉시 시도하여 유연한 처리 흐름을 제공.
    

여기서 명시적으로 내가 락을 제어 할 수 있다는거는 내가 원하는 부분에서 lock을 걸어 제한을 둘 수 있는 이점이 있다고 생각했다

- **결론적으로, ReentrantLock을 선택한 이유:**
    1. **명시적 제어**를 통해 원하는 영역에서 유연하게 락을 걸고 해제할 수 있음.
    2. 공정성 모드를 활성화하면 **순차적 처리 요구사항**을 충족할 수 있음.
- **ReentrantLock의 이점 요약:**
    - 명시적 락 관리로 더 세밀한 제어 가능.
    - 공정성 보장을 통한 순차 처리 가능.

## 결론

이번 과제에서 동시성 제어를 처리하지만 순차적으로 처리하는게 중요하다고 생각이 들었다. R**eentrantLock**을 활용하여 공정성을 보장해 문제를 해결했다. 아무리 동시성 제어를 처음 접해보고 처리도 처음해봤다. 동시성이란거는 항상 고려해봐야하는 문제구나 알게되었고 동시성을 어떻게 잘 제어해야할 지 생각을 많이 해보고 고민을 하면서 개발을 진행해야겠다고 생각했다.
